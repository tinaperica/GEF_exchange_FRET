---
title: "R Notebook - Fitting GEF nucleaotide exchange Trp FRET assay with photobleaching"
output: html_notebook
---

```{r, message=FALSE, warning=FALSE}
# import libraries
library(tidyverse)
library(lubridate)
library(minpack.lm)
```

```{r, message=FALSE}
# read in data
inputfilename <- "biotek_test_exp/data/good_data_parsed.txt"
biotek.data <- read_delim(inputfilename, delim = "\t", col_names = T)
```

```{r}
run_nls <- function(data, background_type, deadtime, debug=FALSE) {
  
  #### debug mode: if debug is TRUE, print out condition being fit 
  if (debug) {print(unique(data$condition))}
  
  #### add the (estimated) dead time
  if (deadtime > 0) {
    deadtime_timepoints <- seq(-1*(deadtime), -5, 5)
    timepoints_to_append <- data[1:length(deadtime_timepoints),]
    timepoints_to_append$Time <- deadtime_timepoints
    timepoints_to_append$observed <- NA
    data <- rbind(data, timepoints_to_append)
  }
  
  #### linear fit for background
  if (background_type == 'linear') {
    
    #### set starting values, upper bounds, and lower bounds for parameters (in order, f0, k, c, k_background)
    start <- list(f0 = max(data$observed, na.rm = T),
                  k = 0.001,
                  c = median(data$observed, na.rm = T),
                  k_background = 1e-5)
    
    upper <- c(max(data$observed, na.rm = T),
               1.0,
               median(data$observed, na.rm = T), 
               Inf) 
    
    lower <- c(median(data$observed, na.rm = T),
               1e-10,
               min(data$observed, na.rm = T),
               -Inf)
    
    #### run non-linear least-squares regression with LM algorithm. format: out <- nlsLM(y ~ f(x))
    out <- nlsLM(observed ~ (f0 - (c-k_background*Time)) * exp(-k * Time) + (c-k_background*Time),
                 data = data, start = start, upper = upper, lower = lower, control = nls.lm.control(maxiter = 300))
    
    #### save parameters
    f0 <- coef(out)[1]
    k <- coef(out)[2]
    c <- coef(out)[3]
    k_background <- coef(out)[4]
    
    #### calculate ideal curves for overall fit, true exchange signal, and background
    data$predicted <- (f0 - (c-k_background*data$Time)) * exp(-k * data$Time) + (c-k_background*data$Time)
    data$exchange <- (f0 - c) * exp(-k * data$Time) + c
    data$background <- c - k_background * data$Time
  }
  
  #### exponential fit for background
  if (background_type == 'exponential') {

    #### set starting values, upper bounds, and lower bounds for parameters (in order, f0, k, c, k_background)
    start <- list(f0 = max(data$observed, na.rm = T),
                  k = 0.001,
                  c = median(data$observed, na.rm = T),
                  k_background = 1e-5)
    
    upper <- c(max(data$observed, na.rm = T),
               1.0,
               median(data$observed, na.rm = T), 
               1e-3) 
    
    lower <- c(median(data$observed, na.rm = T),
               1e-8,
               min(data$observed, na.rm = T),
               1e-8)
      
    #### run non-linear least-squares regression with LM algorithm. format: out <- nlsLM(y ~ f(x))
    out <- nlsLM(observed ~ (f0 - c * exp(-k_background * Time)) * exp(-k * Time) + c * exp(-k_background * Time),
               data = data, start = start, upper = upper, lower = lower, control = nls.lm.control(maxiter = 300))
    
    #### save optimal parameters
    f0 <- coef(out)[1]
    k <- coef(out)[2]
    c <- coef(out)[3]
    k_background <- coef(out)[4]
    
    #### calculate ideal curves for overall fit, true exchange signal, and background, save
    data$predicted <- (f0 - c * exp(-k_background * data$Time)) * exp(-k * data$Time) + c * exp(-k_background * data$Time)
    data$exchange <- (f0 - c) * (exp(-k * data$Time)) + c
    data$background <- c * exp(-k_background * data$Time)
    data$k_background <- k_background
  }
  
  #### ignore background when fitting
  if  (background_type == 'none') {

    #### set starting values, upper bounds, and lower bounds for parameters (in order, f0, k, c, k_background)
    start <- list(f0 = max(data$observed, na.rm = T),
                  k = 0.001,
                  c = median(data$observed, na.rm = T))
    
    upper <- c(max(data$observed, na.rm = T),
               1.0,
               median(data$observed, na.rm = T)) 
    
    lower <- c(median(data$observed, na.rm = T),
               1e-8,
               min(data$observed, na.rm = T))
    
    #### run non-linear least-squares regression with LM algorithm. format: out <- nlsLM(y ~ f(x))
    out <- nlsLM(observed ~ (f0 - c) * exp(-k * Time) + c,
               data = data, start = start, upper = upper, lower = lower, control = nls.lm.control(maxiter = 300))
    
    #### save optimal parameters
    f0 <- coef(out)[1]
    k <- coef(out)[2]
    c <- coef(out)[3]
    
    #### calculate ideal curves for overall fit, and true exchange signal (ignore background)
    data$predicted <- (f0 - c) * (exp(-k * data$Time)) + c
    data$exchange <- (f0 - c) * (exp(-k * data$Time)) + c
    data$background <- 0
  }
  
  #### ignore background when fitting, use cutoff points
  if (background_type == 'cutoff') {
    
    #### set starting values, upper bounds, and lower bounds for parameters (in order, f0, k, c, k_background)
    start <- list(f0 = max(data$observed, na.rm = T),
                  k = 0.001,
                  c = median(data$observed, na.rm = T))
    
    upper <- c(max(data$observed, na.rm = T),
               1.0,
               median(data$observed, na.rm = T)) 
    
    lower <- c(median(data$observed, na.rm = T),
               1e-8,
               min(data$observed, na.rm = T))
    
    #### run non-linear least-squares regression with LM algorithm. format: out <- nlsLM(y ~ f(x))
    out <- nlsLM(observed ~ (f0 - c) * exp(-k * Time) + c,
               data = data, start = start, upper = upper, lower = lower, control = nls.lm.control(maxiter = 300))
    f0 <- coef(out)[1]
    k <- coef(out)[2]
    c <- coef(out)[3]

    data$predicted <- (f0 - c)* exp(-k * data$Time) + c
    cutoff_time_range <- c(data$cutoff_time - 20, data$cutoff_time + 20)
    data$min.fluorescence <- min(data$predicted[findInterval(data$Time, cutoff_time_range) == 1])
    data$max.fluorescence <- max(data$predicted)
    
    ####run non-linear least-squares regression with LM algorithm. format: out <- nlsLM(y ~ f(x))
    out <- nlsLM(observed ~ (f0 - c) * exp(-k * Time) + c,
               data = data, start = start, upper = upper, lower = lower, control = nls.lm.control(maxiter = 300))
    
    #### save optimal parameters
    f0 <- coef(out)[1]
    k <- coef(out)[2]
    c <- coef(out)[3]
    
    #### calculate ideal curves for overall fit, and true exchange signal (ignore background)
    data$predicted <- (f0 - c) * (exp(-k * data$Time)) + c
    data$exchange <- (f0 - c) * (exp(-k * data$Time)) + c
    data$background <- 0
  }
  
  #### save optimal parameters in the data table
  data$f0 <- f0
  data$k <- k
  data$c <- c
  if (background_type %in% c('linear', 'exponential')) {data$k_background <- k_background}
  else {data$k_background <- 0.0}
  data$v0 = (f0 * k * exp(k * 0)) / (data$GEF_conc[1]*0.001)
  
  return(data)
}
```

```{r}
plot_data <- function(data, background_type, units) {
  
  #### Call this to get rid of the "[[1]] [[2]] [[3]]..." printing during pdf plotting. note that it clears errors, must be removed when debugging
  sink('/dev/null')  
  
  #### set date, for filenaming purposes
  today = gsub('-', '', today(tzone="US/Pacific"))
  
  #### plot data with fitted curves
  plots <- list()
  conditions = unique(data$condition)
  for (i in seq_along(1:length(conditions))) {
    data_to_plot <- data %>% filter(condition == conditions[i])
    
    if (background_type %in% c('linear', 'exponential')) {
      plots[[i]] <- ggplot(data_to_plot, mapping = aes(x = Time, y = observed)) + geom_point(color = "black") +
        geom_line(data_to_plot, mapping = aes(x = Time, y = predicted), color = "red") +
        geom_line(data_to_plot, mapping = aes(x = Time, y = exchange), color = "green") +
        geom_line(data_to_plot, mapping = aes(x = Time, y = background), color = "blue") +
        ggtitle(conditions[i])
    } else {
      plots[[i]] <- ggplot(data_to_plot, mapping = aes(x = Time, y = observed)) + geom_point(color = "black") +
        geom_line(data_to_plot, mapping = aes(x = Time, y = predicted), color = "red") +
        geom_line(data_to_plot, mapping = aes(x = Time, y = exchange), color = "green") +
        ggtitle(conditions[i])
    }
  pdf(paste(today, background_type, units, 'data.pdf', sep= '_'))
  print(plots)
  dev.off()
  }

  #### make michaelis-menten plot of v0 vs. conc
  plots <- list()
  samples = unique(data$sample)
  for (i in seq_along(1:length(samples))) {
    data_to_plot <- data %>% filter(sample == samples[i])
    plots[[i]] <- ggplot(data_to_plot, mapping = aes(x = conc, y = v0, color=as.character(date))) + geom_point() +
      ggtitle(samples[i])
      # + geom_text(aes(label=condition),hjust=0, vjust=0)  # use this to label each point on the plot (useful for finding outliers)
  }
  pdf(paste(today, background_type, units, 'MM.pdf', sep= '_'))
  print(plots)
  dev.off()

  #### plot histograms showing distribution of parameters across all fits
  pdf(paste(today, background_type, units, 'params.pdf', sep= '_'))
  hist(unique(data$f0), breaks=length(unique(data$condition)))
  hist(unique(data$k), breaks=length(unique(data$condition)))
  hist(unique(data$c), breaks=length(unique(data$condition)))
  if (background_type != 'none') {
    hist(unique(data$k_background), breaks=length(unique(data$condition)))
    print(ggplot(data, aes(x = conc, y = k_background, color=sample)) + geom_point())
  }
  hist(unique(data$v0), breaks=100)
  dev.off()

  return(data)
}
```

```{r}
# fit_MM <- function(data) {
#   #function(pars, xx) (conc * pars$Vmax) / (pars$Km + conc)
#   start <- list(Vmax = 5, Km = 2)
#   out <- nlsLM(v0 ~ (conc * Vmax) / (Km + conc),
#              data = data, start = start, control = nls.lm.control(maxiter = 200))
#   Vmax<- coef(out)[1]
#   Km <- coef(out)[2]
#   kcat <- Vmax
#   data$predicted_v0 <- (data$conc * Vmax) / (Km + data$conc)
#   data$kcat <- kcat
#   data$Km <- Km
#   return(data)
# }
```

```{r}
#### Make a copy of data to be transformed
data.exp <- biotek.data

#### Fit data assuming photobleaching decay is exponential, with observations in fluorescence units
data.exp <- data.exp %>%
  group_by(condition) %>%
  mutate(observed = fluorescence) %>%
  do(run_nls(., background_type = 'exponential', deadtime = 18)) %>%
  plot_data(data.exp, background_type = 'exponential', units = 'fluor')

#### save data table with fits in fluorescent units
data.exp.fluor <- data.exp

#### Fit data assuming photobleaching decay is exponential, with observations in concentration units
data.exp <- data.exp %>%
  mutate(observed = conc - conc*(f0 - observed)/(f0 - c)) %>%
  do(run_nls(., background_type = 'none', deadtime = 18)) %>%
  plot_data(data.exp, background_type = 'none', units = 'conc')

#### save data table with fits in concentration units
data.exp.conc <- data.exp

#### FIX fit michaelis-menten curve to v0 in concentration units
# MM.data <- data.exp %>%
#   group_by(sample) %>%
#   select(v0, conc) %>%
#   unique() %>%
#   do(fit_MM(.))
```

```{r}
# Run data assuming photobleaching decay is linear, first in fluorescence units, then in concentration units
data.lin <- biotek.data
data.lin <- data.lin %>%
  group_by(condition) %>%
  mutate(observed = fluorescence) %>%
  do(run_nls(., background_type = 'linear', deadtime = 20))
plot_data(data.exp, background_type = 'linear', units = 'fluor')
data.exp <- data.exp %>% 
  mutate(observed = conc - conc*(max.fluorescence - exchange)/(max.fluorescence - min.fluorescence)) %>%
  do(run_nls(., background_type = 'none', deadtime = 0))
plot_data(data.exp, background_type = 'linear', units = 'conc')
```

```{r}
# Run data ignoring photobleaching and using cutoff time, first in fluorescence units, then in concentration units
data.nodecay <- biotek.data
data.nodecay <- data.nodecay %>%
  group_by(condition) %>%
  mutate(relevant = ifelse(Time < cutoff_time, "relevant", "discarded")) %>%
  filter(relevant == "relevant") %>%
  mutate(observed = fluorescence) %>%
  do(run_nls(., background_type = 'cutoff', deadtime = 20)) %>%
  plot_data(background_type = 'cutoff', units = 'fluor') %>%
  mutate(observed = conc - conc*((max(fluorescence, na.rm = T) - fluorescence)/(max(fluorescence, na.rm = T) - min.fluorescence))) %>%
  do(run_nls(., background_type = 'none', deadtime = 0)) %>%
  plot_data(background_type = 'none', units = 'conc')
```

